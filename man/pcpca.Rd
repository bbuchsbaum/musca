% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semipca.R
\name{pcpca}
\alias{pcpca}
\title{Consistent estimating the common principle components (CPCs) with or without knowing the number of CPCs
in partial common principle component analysis}
\usage{
pcpca(Cs, ns, k)
}
\arguments{
\item{Cs}{a list sample covariance matrices with dimension p.}

\item{ns}{the number of samples to estimate each covariance matrix.}

\item{k}{the number of CPCs (an integer between 1 and p). If not specified, a sequential testing procedure is used to estimate k.}
}
\value{
a p-by-k (or p-by-\hat{k} if k is not given) orthogonal matrix, which is an estimate of covariacne matrices.
}
\description{
Consistent estimating the common principle components (CPCs) with or without knowing the number of CPCs
in partial common principle component analysis
}
\examples{
set.seed(1234)
p <- 4 # dimension of covariance matrices
k <- 2 # number of CPCs
n <- 20 # numbder of covariance matrices
ns <- 20 # number of samples the estimate each matrix
lambda <- exp(4:1) # eigenvalues
gamma_true <- svd(matrix(rnorm(p^2), p, p))$u[,1:k] # true common eigenvectors
cov <- purrr::map(1:n, function(j){
  lambda_common <- sample(lambda, 2)
  lambda_individual <- setdiff(lambda,  lambda_common)
  temp <- gramSchmidt(cbind(gamma_true, matrix(rnorm(p*(p-k)), p, p-k)))$Q[,(k+1):p]
  gamma_true \%*\% diag(lambda_common, nrow = k) \%*\% t(gamma_true) +
  temp \%*\% diag(lambda_individual, nrow = p-k) \%*\% t(temp)
}) # generate covariance matrices
cov_data <- map(cov, ~cov(MASS::mvrnorm(ns, rep(0,p), .))) # generate sample covariance matrices from a wishart distribution
gamma_hat <- pcpca(cov_data, ns, k)
t(gamma_hat) \%*\% gamma_true
gamma_hat <- pcpca(cov_data, ns)
t(gamma_hat) \%*\% gamma_true
}
